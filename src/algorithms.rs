use num_bigint::{BigInt, RandBigInt};
#[allow(unused_imports)]
use num_traits::identities::{One, Zero};

/// Checks if n is a probable prime
pub fn miller_rabin(n: &BigInt, k: isize) -> bool {
    if *n <= BigInt::from(2) {
        return false;
    }

    // Find s & d so that 2^s * d = n - 1
    let mut s: BigInt = BigInt::zero();
    let mut d: BigInt = n - 1;
    while &d % 2 == BigInt::zero() {
        d /= 2;
        s += 1;
    }

    for _ in 0..k {
        let a = rand::thread_rng().gen_bigint_range(&BigInt::from(2), &(n - 2));
        let mut x = modular_pow(&a, &d, &n);
        let mut y = BigInt::zero();

        let mut m: BigInt = s.clone();
        while m > BigInt::zero() {
            y = modular_pow(&x, &BigInt::from(2), &n);
            if y == BigInt::one() && x != BigInt::one() && x != n - 1 {
                return false;
            }
            x = y.clone();

            m -= 1;
        }

        if y != BigInt::one() {
            return false;
        }
    }

    true
}

/// Returns result for base^exponent % modulus
pub fn modular_pow(base: &BigInt, exponent: &BigInt, modulus: &BigInt) -> BigInt {
    if *modulus == BigInt::one() {
        return BigInt::zero();
    }

    let mut exponent = exponent.clone();
    let mut base = base % modulus;
    let mut result = BigInt::one();

    while exponent > 0.into() {
        if &exponent % 2 == BigInt::one() {
            result = (result * &base) % modulus;
        }
        exponent >>= 1;
        base = (&base * &base) % modulus;
    }

    return result;
}

/// Returns the greatest common divisor of two numbers,
/// and the coefficients of BÃ©zout's identity.
pub fn extended_eucledian(a: &BigInt, b: &BigInt) -> (BigInt, BigInt, BigInt) {
    let (mut old_r, mut r) = (a.clone(), b.clone());
    let (mut old_s, mut s) = (BigInt::one(), BigInt::zero());
    let (mut old_t, mut t) = (BigInt::zero(), BigInt::one());

    while &r != &BigInt::zero() {
        let quotient = &old_r / &r;
        old_r = old_r - &quotient * &r;
        (old_r, r) = (r, old_r);
        old_s = old_s - &quotient * &s;
        (old_s, s) = (s, old_s);
        old_t = old_t - &quotient * &t;
        (old_t, t) = (t, old_t);
    }

    (old_r, old_s, old_t)
}

/// Calculates the least common multiple of two numbers.
pub fn least_common_multiple(a: &BigInt, b: &BigInt) -> BigInt {
    let (qcd, _, _) = extended_eucledian(a, b);
    a * b / qcd
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use super::*;
    use num_bigint::BigInt;

    #[test]
    fn miller_rabin_returns_false_for_number_under_two() {
        let numbers = [BigInt::from(2), BigInt::one(), BigInt::zero()];
        for number in numbers {
            let res = miller_rabin(&number, 4);
            assert!(!res)
        }
    }

    #[test]
    fn miller_rabin_returns_true_for_prime() {
        let prime = BigInt::from(7919); // 1000th prime
        let res = miller_rabin(&prime, 4);
        assert!(res)
    }

    #[test]
    fn miller_rabin_returns_false_for_nonprime() {
        let nonprime = BigInt::from(7921);
        let res = miller_rabin(&nonprime, 4);
        assert!(!res)
    }

    // from https://t5k.org/curios/index.php
    const PRIME_STRS: [&str; 5] = [
        "7891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891",
        "9090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909091",
        "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000118000000080101811009000118101080000000811000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
        "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000237",
        "115922179551495973383410176342643722334557255682879605864838806293659619625004303206250384392546855063844106965156287951749387634112551089284595541103692716528774876311641700929986988023197242224581099872580798960693521778607396791006450968430359009613295725905514216842343121690916290236558767890728449777",
    ];

    #[test]
    fn miller_rabin_returns_true_for_primes() {
        for prime in PRIME_STRS.iter() {
            assert!(miller_rabin(&BigInt::from_str(prime).unwrap(), 4));
        }
    }

    #[test]
    fn miller_rabin_returs_false_for_product_of_primes() {
        for (i, prime1) in PRIME_STRS.iter().enumerate() {
            for prime2 in &PRIME_STRS[i..] {
                let product = BigInt::from_str(prime1).unwrap() * BigInt::from_str(prime2).unwrap();
                assert!(!miller_rabin(&product, 4));
            }
        }
    }

    #[test]
    fn modular_pow_returns_correct_remainder() {
        let result = modular_pow(&BigInt::from(3), &BigInt::from(2), &BigInt::from(5));

        assert_eq!(BigInt::from(4), result);
    }

    #[test]
    fn modular_pow_returns_correct_remainder_for_large_numbers() {
        let base = BigInt::from_str(
            "7891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891",
        ).unwrap();
        let exp = BigInt::from_str("65537").unwrap();
        let modulus = BigInt::from_str(
            "9090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909091",
        ).unwrap();

        let result = modular_pow(&base, &exp, &modulus);

        assert_eq!(BigInt::from_str(
            "3780598656799218479006636905183739057884678626311303504042908176449915991258133319420988864937869895413640620556032885623866168476687204509206429415940738314265589945865516361322301254847517807547717278227531263394128110461099814472970626228269681522126568393369025184735901230803006288058370"
        ).unwrap(), result);
    }

    #[test]
    fn modular_pow_returns_zero_for_mod_of_one() {
        let result = modular_pow(&BigInt::from(123456), &BigInt::from(5), &BigInt::one());

        assert_eq!(BigInt::zero(), result);
    }

    #[test]
    fn extended_eucledian_returns_correctly() {
        let result = extended_eucledian(&BigInt::from(240), &BigInt::from(46));
        assert_eq!(
            (BigInt::from(2), BigInt::from(-9), BigInt::from(47)),
            result
        );
    }

    #[test]
    fn extended_eucledian_returns_correctly_with_large_numbers() {
        let num1 = BigInt::from_str(
            "7891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891",
        ).unwrap();
        let num2 = BigInt::from_str(
            "9090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909091",
        ).unwrap();

        let result = extended_eucledian(&num1, &num2);
        assert_eq!((BigInt::one(), BigInt::from_str(
            "-1565254968256642842120760732639891295618419244388511884847262788499763504923206107099763964297188959968386202550962856475308099051505328101607291461480018368749242092383346847591649046753029607946349169767219942557687102906620159332979787118740187225931945982708618131638164625817312333117865"
        ).unwrap(), BigInt::from_str(
            "1358697352437734876422931662981802987910800104438448320232968968414212443820653203439012267358516466851344894841049902813419719180565346345915037838085681105185653854240093589580143699344285632306528563678911811920479690534009410487332241315545234116341151154489526233614354785738449551973981710942592200152216960300249094711535845421564680145082522199876"
        ).unwrap()), result);
    }

    #[test]
    fn least_common_multiple_returns_correctly() {
        let result = least_common_multiple(&BigInt::from(4), &BigInt::from(6));
        assert_eq!(BigInt::from(12), result);
    }

    #[test]
    fn least_common_multiple_returns_correctly_for_large_numbers() {
        let num1 = BigInt::from_str(
            "7891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891",
        ).unwrap();
        let num2 = BigInt::from_str(
            "9090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909091",
        ).unwrap();

        let result = least_common_multiple(&num1, &num2);
        assert_eq!(BigInt::from_str(
            "71738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071738496071739213456699213456699213456699213456699213456699213456699213456697081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081021324353748597081"
        ).unwrap(), result);
    }
}
